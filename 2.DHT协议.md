# DHT协议

http://www.bittorrent.org/beps/bep_0003.html

BitTorrent使用“分布式草率哈希表"（DHT）来存储“无追踪程序"种子的对等联系信息。实际上，每个对等方都成为跟踪器。该协议基于Kademila [[1]，](http://www.bittorrent.org/beps/bep_0005.html#kademlia)并通过UDP实现。

请注意本文档中使用的术语，以避免混淆。“对等"是侦听实现BitTorrent协议的TCP端口的客户端/服务器。“节点"是侦听实现分布式哈希表协议的UDP端口的客户端/服务器。DHT由节点组成，并存储对等体的位置。BitTorrent客户端包括一个DHT节点，该节点用于联系DHT中的其他节点，以获取要使用BitTorrent协议下载的对等方的位置。

## 总览

每个节点都有一个全局唯一的标识符，称为“节点ID"。节点ID是从与BitTorrent信息哈希[[2]](http://www.bittorrent.org/beps/bep_0005.html#entropy)相同的160位空间中随机选择的。“距离量度"用于比较两个节点ID或一个节点ID和一个信息散列，以表示“紧密度"。节点必须维护一个路由表，其中包含少量其他节点的联系信息。ID越接近节点自己的ID，路由表就越详细。节点知道DHT中的许多其他节点，这些节点的ID与其自身“很近"，但只有少数联系人与ID的距离很远。

在Kademlia中，距离量度为XOR，结果解释为无符号整数。<tt class="docutils literal">distance（A，B）= | A xor B | </tt>较小的值更接近。

当节点想要为torrent查找对等节点时，它使用距离度量将torrent的信息哈希与其自己的路由表中的节点ID进行比较。然后，它以最接近信息哈希的ID与它知道的节点联系，并要求它们提供当前正在下载torrent的对等方的联系信息。如果联系的节点知道该torrent的对等节点，则该对等联系人信息将与响应一起返回。否则，被联系节点必须以其路由表中最接近torrent信息哈希的节点的联系信息作为响应。原始节点迭代查询更接近目标信息哈希的节点，直到找不到任何更接近的节点为止。搜索结束后，

对等查询的返回值包括一个不透明的值，称为“令牌"。为了使节点宣布其控制对等方正在下载洪流，它必须在最近的对等方查询中提供从同一查询节点收到的令牌。当节点尝试“宣布"种子文件时，被查询节点将根据查询节点的IP地址检查令牌。这是为了防止恶意主机注册其他主机的种子。由于令牌仅由查询节点返回到接收令牌的相同节点，因此未定义实现。令牌分发后，必须在合理的时间内接受令牌。

## 路由表

每个节点都维护一个已知良好节点的路由表。路由表中的节点用作DHT中查询的起点。响应于来自其他节点的查询，返回路由表中的节点。

并非我们了解的所有节点都是平等的。有些是“好"的，有些则不是。使用DHT的许多节点都可以发送查询和接收响应，但不能响应来自其他节点的查询。重要的是，每个节点的路由表必须仅包含已知的良好节点。一个好的节点是一个节点在过去15分钟内已响应我们的查询之一。如果某个节点曾经响应我们的一个查询并在过去15分钟内向我们发送了查询，则它也很好。闲置15分钟后，一个节点变得可疑。当节点无法连续响应多个查询时，它们将变得很糟糕。我们知道状态良好的节点将优先于状态未知的节点。

路由表覆盖了从0到2 <sup>160</sup>的整个节点ID空间。路由表被细分为“存储桶"，每个存储桶覆盖一部分空间。一个空表有一个存储桶，其ID空间范围为min = 0，max = <sup>2160</sup>。当将ID为"N"的节点插入到表中时，该节点将被放置在min≤N≤的存储桶中。最高 空表只有一个存储桶，因此任何节点都必须位于其中。每个存储桶只能容纳K个节点（当前为8个），然后再变为“满"。当存储桶中充满了已知良好的节点时，除非我们自己的节点ID落入存储桶的范围内，否则无法再添加更多节点。在这种情况下，该存储桶将被两个新存储桶替换，每个新存储桶的范围均为旧存储桶的一半，并且旧存储桶中的节点将分布在两个新存储桶中。对于只有一个存储桶的新表，整个存储桶始终会分成两个新存储桶，覆盖范围0..2 <sup>159</sup>和2 <sup>159</sup> ..2 <sup>160</sup>。

当存储桶中充满了良好的节点时，只需丢弃新节点。如果已知存储桶中的任何节点已损坏，则将其替换为新节点。如果最近15分钟内未看到存储桶中有任何可疑节点，则对最近最少看到的节点执行ping操作。如果ping节点做出响应，则对最近最少看到的下一个可疑节点进行ping操作，直到一个节点无法响应或已知存储桶中的所有节点均正常为止。如果存储桶中的某个节点无法响应ping，建议在丢弃该节点并将其替换为新的良好节点之前再试一次。这样，该表将填充稳定且长期运行的节点。

每个存储桶都应保持“最后更改"属性，以指示内容的“新鲜程度"。当对存储桶中的节点执行ping操作并响应时，或将节点添加到存储桶，或将存储桶中的节点替换为另一个节点时，应更新存储桶的上次更改的属性。15分钟内未更换的水桶应“重新整理"。通过选择存储桶范围内的随机ID并对其执行find_nodes搜索，即可完成此操作。能够从其他节点接收查询的节点通常不需要经常刷新存储桶。无法接收来自其他节点的查询的节点通常将需要定期刷新所有存储桶，以确保需要DHT时表中有良好的节点。

在将第一个节点插入其路由表后以及随后启动时，该节点应尝试在DHT中查找与其自身最近的节点。它通过向越来越近的节点发出find_node消息来进行此操作，直到找不到任何更近的节点为止。路由表应在客户端软件调用之间保存。

## BitTorrent协议扩展

BitTorrent协议已扩展为在跟踪器引入的对等点之间交换节点UDP端口号。通过这种方式，客户端可以通过下载常规torrent来自动获得其路由表的种子。新安装的客户端尝试在第一次尝试中下载无追踪程序的torrent时，其路由表中将没有任何节点，并且需要torrent文件中包含的联系人。

支持DHT的对等方设置了在BitTorrent协议握手中交换的8字节保留标志的最后一位。对等方收到表示远程对等方支持DHT的握手时，应发送PORT消息。它以字节0x09开头，并具有两个字节的有效负载，其中包含以网络字节顺序排列的DHT节点的UDP端口。收到此消息的对等方应尝试对收到的端口和远程对等方的IP地址上的节点执行ping操作。如果收到对ping的响应，则节点应尝试按照通常的规则将新的联系信息插入其路由表。

## 种子文件扩展名

无追踪程序的torrent词典没有“宣布"键。取而代之的是，无追踪程序的torrent具有“节点"键。该密钥应设置为在洪流生成客户的路由表中的K个最近的节点。或者，可以将密钥设置为已知的良好节点，例如由洪流生成者操作的节点。请不要将"router.bittorrent.com"自动添加到torrent文件中，也不要将此节点自动添加到客户端路由表中。

节点= [["<主机>"，<端口>]，["<主机>"，<端口>]，...]
节点= [["127.0.0.1"，6881]，[“您的路由器。节点"，4804]，["2001：db8：100：0：d5c8：db3f：995e：c0f7"，1941]]

## KRPC协议

KRPC协议是一种简单的RPC机制，由通过UDP发送的本编码字典组成。发送单个查询数据包，并作为响应发送单个数据包。没有重试。共有三种消息类型：查询，响应和错误。对于DHT协议，有四个查询：ping，find_node，get_peers和announce_peer。

KRPC消息是单个字典，具有每个消息共有的三个键以及取决于消息类型的其他键。每个消息都有一个键"t"，它的字符串值表示事务ID。此事务ID由查询节点生成，并在响应中回显，因此响应可能与对同一节点的多个查询相关。交易ID应该编码为一串短的二进制数字，通常2个字符就足够了，因为它们覆盖了2 ^ 16个未完成的查询。每个消息还具有键"y"，该键带有描述消息类型的单个字符值。"y"键的值是用于查询的"q"，用于响应的"r"或用于错误的"e"之一。带有客户端版本字符串的每条消息中都应包含键"v"。[[3]，](http://www.bittorrent.org/beps/bep_0005.html#bep-20)后跟两个字符的版本标识符。并非所有实现都包含"v"键，因此客户端不应假定其存在。

### 联系人编码

对等方的联系信息被编码为6字节的字符串。4字节IP地址也称为“紧凑IP地址/端口信息"，以网络字节顺序排列，而以网络字节顺序排列的2字节端口连接在末尾。

节点的联系信息被编码为26字节的字符串。网络字节顺序的20字节节点ID也称为“紧凑节点信息"，其紧凑IP地址/端口信息连接到末尾。

### 查询

查询或"y"值为"q"的KRPC消息字典包含两个附加键；"q"和"a"。键"q"具有一个字符串值，其中包含查询的方法名称。键"a"的字典值包含查询的命名参数。

### 回应

响应或"y"值为"r"的KRPC消息字典包含一个附加键"r"。"r"的值是一个包含命名返回值的字典。成功完成查询后，将发送响应消息。

### 失误

错误或"y"值为"e"的KRPC消息字典包含一个附加键"e"。"e"的值是一个列表。第一个元素是代表错误代码的整数。第二个元素是包含错误消息的字符串。无法满足查询条件时发送错误。下表描述了可能的错误代码：

<colgroup><col width="19%"><col width="81%"></colgroup>
| 码 | 描述 |
| 201 | 一般错误 |
| 202 | 服务器错误 |
| 203 | 协议错误，例如格式错误的数据包，无效的参数或错误的令牌 |
| 204 | 方法未知 |

错误包示例：

一般错误= {"t"："aa"，"y"："e"，"e"：[201，“发生一般错误"]}
bencoded = d1：eli201e23：发生一般错误e1：t2：aa1：y1：ee

## DHT查询

所有查询都具有"id"键和包含查询节点的节点ID的值。所有响应均具有"id"键和包含响应节点的节点ID的值。

### ping

最基本的查询是ping。"q" ="ping" ping查询具有单个参数"id"，该值是一个20字节的字符串，其中包含以网络字节顺序排列的发送者节点ID。对ping的适当响应具有包含响应节点的节点ID的单个键"id"。

参数：{"id"："<查询节点ID>"}

响应：{"id"："<查询的节点id>"}

示例数据包

ping查询= {"t"："aa"，"y"："q"，"q"："ping"，"a"：{"id"："abcdefghij0123456789"}}
bencoded = d1：ad2：id20：abcdefghij0123456789e1：q4：ping1：t2：aa1：y1：qe
响应= {"t"："aa"，"y"："r"，"r"：{"id"："mnopqrstuvwxyz123456"}}
bencoded = d1：rd2：id20：mnopqrstuvwxyz123456e1：t2：aa1：y1：re

### find_node

查找节点用于查找给定其ID的节点的联系信息。"q" =="find_node" find_node查询具有两个参数，"id"包含查询节点的节点ID，"target"包含查询者寻求的节点ID。当节点接收到find_node查询时，它应使用键"nodes"和包含其目标路由表中目标节点或K（8）个最接近的良好节点的紧凑节点信息的字符串值进行响应。

参数：{"id"："<查询节点ID>"，"target"："<目标节点ID>"}

响应：{"id"："<查询的节点id>"，"nodes"："<紧凑节点信息>"}

示例数据包

find_node Query = {"t"："aa"，"y"："q"，"q"："find_node"，"a"：{"id"："abcdefghij0123456789"，"target"："mnopqrstuvwxyz123456"}}
bencoded = d1：ad2：id20：abcdefghij01234567896：target20：mnopqrstuvwxyz123456e1：q9：find_node1：t2：aa1：y1：qe
响应= {"t"："aa"，"y"："r"，"r"：{"id"："0123456789abcdefghij"，“节点"："def456 ..."}}
bencoded = d1：rd2：id20：0123456789abcdefghij5：nodes9：def456 ... e1：t2：aa1：y1：re

### get_peers

获取与torrent信息哈希关联的对等节点。"q" ="get_peers" get_peers查询具有两个参数，"id"包含查询节点的节点ID，"info_hash"包含种子的infohash。如果查询的节点具有infohash的对等节点，则它们在键“值"中作为字符串列表返回。每个包含“紧凑"格式的字符串的单个对等方信息。如果查询的节点没有infohash的对等节点，则返回键"nodes"，其中包含查询的节点路由表中最接近查询中提供的infohash的K个节点。无论哪种情况，返回值中都包含一个“令牌"键。令牌值是将来的announce_peer查询的必需参数。令牌值应为简短的二进制字符串。

参数：
{"id"："<查询节点id>"，"info_hash"："<目标torrent的20字节infohash>"}

响应：{"id"："<查询的节点id>"，“令牌"："<不透明的写令牌>"，“值"：["<对等1信息字符串>"，"<对等2信息字符串>"] }

或：{"id"："<查询的节点id>"，“令牌"："<不透明的写令牌>"，"nodes"："<紧凑节点信息>"}

示例数据包：

get_peers查询= {"t"："aa"，"y"："q"，"q"："get_peers"，"a"：{"id"："abcdefghij0123456789"，"info_hash"："mnopqrstuvwxyz123456"}}
bencoded = d1：ad2：id20：abcdefghij01234567899：info_hash20：mnopqrstuvwxyz123456e1：q9：get_peers1：t2：aa1：y1：qe
与同级的响应= {"t"："aa"，"y"："r"，"r"：{"id"："abcdefghij0123456789"，"token"："aoeusnth"，"values"：["axje。 u“，" idhtnm“]}}
bencoded = d1：rd2：id20：abcdefghij01234567895：token8：aoeusnth6：valuesl6：axje.u6：idhtnmee1：t2：aa1：y1：re
具有最近节点的响应= {"t"："aa"，"y"："r"，"r"：{"id"："abcdefghij0123456789"，"token"："aoeusnth"，"nodes"："def456。 ..“}}
bencoded = d1：rd2：id20：abcdefghij01234567895：nodes9：def456 ... 5：token8：aoeusnthe1：t2：aa1：y1：re

### announce_peer

宣布控制查询节点的对等方正在端口上下载洪流。announce_peer有四个参数："id"包含查询节点的节点ID，"info_hash"包含torrent的信息哈希，"port"包含端口作为整数，以及响应先前的get_peers查询而收到的"token" 。被查询节点必须验证令牌先前是否已发送到与查询节点相同的IP地址。然后，被查询的节点应将查询节点的IP地址和所提供的端口号存储在其对等联系信息存储区中的信息散列下。

有一个名为<tt class="docutils literal">implied_port</tt>的可选参数，其值为0或1。如果存在且非零，则应忽略<tt class="docutils literal">port</tt>参数，而应将UDP数据包的源端口用作对等方的端口。这对于NAT后的对等点（可能不知道其外部端口）并且支持uTP很有用，它们支持与DHT端口在同一端口上的传入连接。

参数：{"id"："<查询节点ID>"，
  "implied_port"：<0或1>，
  "info_hash"："<目标torrent的20字节infohash>"，
  "port"：<端口号>，
  "token"："<不透明令牌>"}

响应：{"id"："<查询的节点id>"}

示例数据包：

notify_peers查询= {"t"："aa"，"y"："q"，"q"："announce_peer"，"a"：{"id"："abcdefghij0123456789"，"implied_port"：1，"info_hash" ："mnopqrstuvwxyz123456"，“端口"：6881，“令牌"："aoeusnth"}}
bencoded = d1：ad2：id20：abcdefghij012345678912：implied_porti1e9：info_hash20：mnopqrstuvwxyz1234564：porti6881e5：token8：aoeusnthe1：q13：announce_peer1：t2：aa1：y1：qe
响应= {"t"："aa"，"y"："r"，"r"：{"id"："mnopqrstuvwxyz123456"}}
bencoded = d1：rd2：id20：mnopqrstuvwxyz123456e1：t2：aa1：y1：re